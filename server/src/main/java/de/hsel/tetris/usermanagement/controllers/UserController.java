package de.hsel.tetris.usermanagement.controllers;

import de.hsel.tetris.exception.ResourceNotFoundException;
import de.hsel.tetris.usermanagement.User;
import de.hsel.tetris.usermanagement.UserMapper;
import de.hsel.tetris.usermanagement.services.UserService;
import de.hsel.tetris.usermanagement.dto.UserDto;
import de.hsel.tetris.usermanagement.dto.UserProblemDto;
import de.hsel.tetris.usermanagement.dto.UserRegistrationDto;
import de.hsel.tetris.usermanagement.dto.UserSelfDto;
import de.hsel.tetris.usermanagement.dto.UserUpdateDto;
import de.hsel.tetris.usermanagement.exception.UserValidationException;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.server.ResponseStatusException;

import java.security.Principal;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Pattern;

@Controller // This means that this class is a Controller
@RequestMapping(path = "/api/users") // This means URL's start with /users (after Application path)
public class UserController {

    private final UserService userService;
    private final UserMapper userMapper;

    // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    public UserController(UserService userService, UserMapper userMapper) {
        this.userService = userService;
        this.userMapper = userMapper;
    }

    @Operation(summary = "Add a new user")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "New user created", content = @Content),
            @ApiResponse(responseCode = "400", description = "Request body does not match UserRegistrationDto spec", content = @Content),
            @ApiResponse(responseCode = "409", description = "E-mail address and/or username are already taken",
                    content = {@Content(mediaType = MediaType.APPLICATION_JSON_VALUE, schema = @Schema(implementation = UserProblemDto.class))}),
            @ApiResponse(responseCode = "422", description = "The email address is invalid",
                    content = {@Content(mediaType = MediaType.APPLICATION_JSON_VALUE, schema = @Schema(implementation = UserProblemDto.class))}),
            @ApiResponse(responseCode = "500", description = "Something went wrong on the server", content = @Content),

    })
    @PostMapping
    public ResponseEntity addNewUser(
            @RequestBody UserRegistrationDto userRegistrationDto
    ) {
        var isEmailValid = validateEmail(userRegistrationDto.getEmail());

        if (!isEmailValid) {
            var userProblemDto = new UserProblemDto();
            userProblemDto.setEmail("invalid");
            return ResponseEntity.status(422).body(userProblemDto);
        }

        try {
            userService.register(userRegistrationDto);
            return ResponseEntity.status(201).build();
        } catch (UserValidationException exception) {
            var duplicates = getDuplicates(exception.getErrors());
            return ResponseEntity.status(409).body(duplicates);
        }
    }

    @Operation(summary = "Get a list of all users", security = @SecurityRequirement(name = "User Token"))
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "The list of all current users",
                    content = {@Content(mediaType = MediaType.APPLICATION_JSON_VALUE,
                            array = @ArraySchema(schema = @Schema(implementation = User.class)))}),
            @ApiResponse(responseCode = "401", description = "Authorization token is missing or invalid",
                    content = @Content),
            @ApiResponse(responseCode = "500", description = "Something went wrong on the server", content = @Content)
    })
    @GetMapping
    public @ResponseBody List<UserDto> getAllUsers(Principal principal) {
        var result = new ArrayList<UserDto>();
        for (var user : userService.getAllUsers()) {
            if (user.getUsername().equals(principal.getName())) {
                result.add(userMapper.toSelfDto(user));
            } else {
                result.add(userMapper.toDto(user));
            }
        }
        return result;
    }

    @Operation(summary = "Get a single user by their ID", security = @SecurityRequirement(name = "User Token"))
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "The requested user data",
                    content = {@Content(mediaType = MediaType.APPLICATION_JSON_VALUE,
                            array = @ArraySchema(schema = @Schema(implementation = User.class)))}),
            @ApiResponse(responseCode = "401", description = "Authorization token is missing or invalid",
                    content = @Content),
            @ApiResponse(responseCode = "404", description = "The requested user does not exist",
                    content = @Content),
            @ApiResponse(responseCode = "500", description = "Something went wrong on the server", content = @Content)
    })
    @GetMapping(path = "/{id}")
    @ResponseBody
    public UserDto getUser(@PathVariable("id") Integer id, Principal principal) {
        var user = userService.getUser(id).orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

        if (user.getUsername().equals(principal.getName())) {
            return userMapper.toSelfDto(user);
        }
        return userMapper.toDto(user);
    }

    @Operation(summary = "Update data of a user identified by their ID", security = @SecurityRequirement(name = "User Token"))
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "The user data was updated properly", content = @Content),
            @ApiResponse(responseCode = "400", description = "Request body does not match UserUpdateDto spec", content = @Content),
            @ApiResponse(responseCode = "401", description = "Authorization token is missing or invalid", content = @Content),
            @ApiResponse(responseCode = "403", description = "Access to foreign user data is prohibited", content = @Content),
            @ApiResponse(responseCode = "404", description = "The requested user does not exist", content = @Content),
            @ApiResponse(responseCode = "409", description = "Email or username are already taken",
                    content = {@Content(mediaType = MediaType.APPLICATION_JSON_VALUE, schema = @Schema(implementation = UserProblemDto.class))}),
            @ApiResponse(responseCode = "422", description = "The email address is invalid",
                    content = {@Content(mediaType = MediaType.APPLICATION_JSON_VALUE, schema = @Schema(implementation = UserProblemDto.class))}),
            @ApiResponse(responseCode = "500", description = "Something went wrong on the server", content = @Content)
    })
    @PatchMapping(path = "/{id}")
    public ResponseEntity updateUser(@PathVariable Integer id, @RequestBody UserUpdateDto updateDto, Principal principal) {
        var userOptional = userService.getUser(id);

        if (userOptional.isEmpty()) {
            return ResponseEntity.status(404).build();
        }

        var user = userOptional.get();

        if (!user.getUsername().equals(principal.getName())) {
            return ResponseEntity.status(403).build();
        }

        if (!validateUpdateDtoStructure(updateDto)) {
            return ResponseEntity.status(400).build();
        }

        if (!validateEmail(updateDto.getEmail())) {
            return ResponseEntity.status(422).body(new UserProblemDto("invalid", null));
        }

        try {
            userService.updateProfilePicture(id, updateDto);
            return ResponseEntity.status(204).build();
        } catch (ResourceNotFoundException e) {
            return ResponseEntity.status(404).build();
        } catch (UserValidationException e) {
            return ResponseEntity.status(409).body(getDuplicates(e.getErrors()));
        }
    }

    @Operation(summary = "This can only be done by the logged in user.", security = @SecurityRequirement(name = "User Token"))
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "successful operation", content = @Content),
            @ApiResponse(responseCode = "401", description = "Access token is missing or invalid", content = @Content),
            @ApiResponse(responseCode = "403", description = "Forbidden", content = @Content),
            @ApiResponse(responseCode = "404", description = "User not found", content = @Content),
            @ApiResponse(responseCode = "500", description = "Internal Server Error", content = @Content)
    })
    @DeleteMapping
    public ResponseEntity deleteUser(Principal principal) {
        if (principal.getName().isEmpty()) {
            var user = userService.getUserByName(principal.getName());
            if (user.isEmpty()) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
            }
            if (user.get().getEmail().isEmpty()) {
                if (userService.deleteUserById(user.get().getId())) {
                    return ResponseEntity.status(HttpStatus.NO_CONTENT).build();
                } else {
                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
                }
            }
        }
        return ResponseEntity.status(403).build();
    }

    @Operation(summary = "Get data of logged in user.", security = @SecurityRequirement(name = "User Token"))
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "The user data", content = @Content(mediaType = MediaType.APPLICATION_JSON_VALUE, schema = @Schema(implementation = UserSelfDto.class))),
            @ApiResponse(responseCode = "401", description = "Access token is missing or invalid", content = @Content),
            @ApiResponse(responseCode = "500", description = "Internal Server Error", content = @Content)
    })
    @GetMapping("/me")
    public @ResponseBody UserSelfDto getMe(final Principal principal) {
        var userOptional = userService.getUserByName(principal.getName());

        if (userOptional.isEmpty()) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND);
        }

        return userMapper.toSelfDto(userOptional.get());
    }

    private boolean validateUpdateDtoStructure(UserUpdateDto updateDto) {
        return updateDto.getEmail().isPresent() || updateDto.getUsername().isPresent() || updateDto.getPassword().isPresent();
    }

    private boolean validateEmail(String email) {
        var pattern = "^[a-zA-Z0-9_!#$%&'*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$";
        return Pattern.compile(pattern)
                .matcher(email)
                .matches();
    }

    private boolean validateEmail(Optional<String> emailOptional) {
        return emailOptional.filter(this::validateEmail).isPresent();
    }

    private UserProblemDto getDuplicates(Map<String, String> errors) {
        return new UserProblemDto(errors.get("email"), errors.get("username"));
    }
}
